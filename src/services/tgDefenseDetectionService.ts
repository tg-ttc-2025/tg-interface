// src/services/tgDefenseDetectionService.ts

export interface TGDetectionImage {
  id: string;
  offenseDetectionId: string;
  path: string;
  bucketName: string;
  fileName: string;
  fileSize: number;
  mimeType: string;
  uploadTimestamp: string;
  isPrimary: boolean;
  // ADD THE PUBLIC URL PROPERTY HERE, which is generated by the backend service
  publicUrl?: string; 
}

export interface TGDetectionDetails {
  color: string;
  speed: string | number;
  [key: string]: any;
}

export interface TGDetectionObject {
  id: string;
  objId: string;
  type: string;
  lat: number;
  lng: number;
  alt?: number;
  groundHeight?: string;
  objective?: string;
  size?: string;
  details: TGDetectionDetails;
  timestamp: string;
  createdAt: string;
  updatedAt: string;
  images: TGDetectionImage[];
}

export interface TGHistoryResponse {
  data: TGDetectionObject[];
  total: number;
  limit: number;
  offset: number;
}

// Map TG backend data to your existing DroneObject interface
export interface DroneObject {
  obj_id: string;
  type: string;
  lat: number;
  lng: number;
  objective: string;
  size: string;
  details: {
    color: string;
    speed: number;
  };
  image?: {
    // The image property on DroneObject will now contain the publicUrl
    publicUrl: string;
    filename: string;
  };
}

// Transform TG detection to DroneObject
export const transformTGDetectionToDrone = (detection: TGDetectionObject): DroneObject => {
  // Get primary image or first image
  const primaryImage = detection.images.find(img => img.isPrimary) || detection.images[0];
  
  // Parse speed - handle both string and number formats
  let speed = 0;
  if (typeof detection.details.speed === 'number') {
    speed = detection.details.speed;
  } else if (typeof detection.details.speed === 'string') {
    // Extract number from strings like "25 km/h" or "25"
    const speedMatch = detection.details.speed.match(/[\d.]+/);
    speed = speedMatch ? parseFloat(speedMatch[0]) : 0;
  }

  return {
    obj_id: detection.objId,
    type: detection.type,
    lat: Number(detection.lat), // Ensure numeric
    lng: Number(detection.lng), // Ensure numeric
    objective: detection.objective || 'Unknown',
    size: detection.size || 'medium',
    details: {
      color: detection.details.color || 'gray',
      speed: speed,
    },
    image: primaryImage && primaryImage.publicUrl ? {
      // Use the publicUrl property from the TGDetectionImage object
      publicUrl: primaryImage.publicUrl, 
      filename: primaryImage.fileName,
    } : undefined,
  };
};

const API_BASE_URL = import.meta.env.VITE_TG_API_URL || 'http://localhost:3000';

export const tgDefenseService = {
  // Get detection history
  async getDetectionHistory(limit: number = 100, offset: number = 0): Promise<DroneObject[]> {
    try {
      const response = await fetch(
        `${API_BASE_URL}/ttc/api/offense/history?limit=${limit}&offset=${offset}`
      );
      
      if (!response.ok) {
        throw new Error(`API error: ${response.status}`);
      }

      const data: TGHistoryResponse = await response.json();
      
      // Transform TG detections to DroneObjects
      return data.data.map(transformTGDetectionToDrone);
    } catch (error) {
      console.error('Error fetching detection history:', error);
      throw error;
    }
  },

  // Get all detections for a specific objId (for tracking history)
  async getDetectionsByObjId(objId: string): Promise<TGDetectionObject[]> {
    try {
      const response = await fetch(
        `${API_BASE_URL}/ttc/api/offense/by-obj-id?objId=${objId}`
      );
      
      if (!response.ok) {
        throw new Error(`API error: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error(`Error fetching detections for ${objId}:`, error);
      throw error;
    }
  },

  // Get latest detection for a specific objId
  async getLatestByObjId(objId: string): Promise<TGDetectionObject | null> {
    try {
      const response = await fetch(
        `${API_BASE_URL}/ttc/api/offense/latest-by-obj-id?objId=${objId}`
      );
      
      if (!response.ok) {
        throw new Error(`API error: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error(`Error fetching latest detection for ${objId}:`, error);
      throw error;
    }
  },

  // Get MinIO image URL (This helper function is now potentially redundant if publicUrl is always returned)
  getImageUrl(imagePath: string): string {
    // Assuming MinIO is accessible at same domain with different port
    const minioUrl = import.meta.env.VITE_MINIO_URL || 'http://localhost:9000';
    return `${minioUrl}/tg-detections/${imagePath}`;
  },
};

export default tgDefenseService;